/**
 * Header Generator
 *
 * Generates file headers for multi-source configuration files
 * Headers include links to all source files
 */

import * as path from "node:path";

export class HeaderGenerator {
  constructor(private projectRoot: string) {}

  /**
   * Generate header for a target file with source links
   */
  generate(targetPath: string, sourcePaths: string[]): string {
    const ext = path.extname(targetPath).toLowerCase();
    const relSources = sourcePaths.map(
      (s) => `file://./${path.relative(this.projectRoot, s)}`,
    );

    // Detect comment style based on extension
    if ([".json", ".jsonc", ".json5"].includes(ext)) {
      return this.generateJsonHeader(relSources);
    } else if ([".yaml", ".yml"].includes(ext)) {
      return this.generateYamlHeader(relSources);
    } else if (ext === ".toml") {
      return this.generateYamlHeader(relSources); // TOML uses # comments like YAML
    } else if ([".ts", ".js", ".mjs", ".cjs"].includes(ext)) {
      return this.generateJsDocHeader(relSources);
    } else {
      return this.generateHashHeader(relSources);
    }
  }

  /**
   * Generate JSON header using $comment properties
   * These are ignored by most JSON parsers but visible in editors
   */
  private generateJsonHeader(sources: string[]): string {
    const header: Record<string, string> = {
      $comment: "ðŸ¤– GENERATED FILE - DO NOT EDIT DIRECTLY",
      $comment2:
        "This file is auto-generated by config-manager. Edit source files instead:",
    };

    sources.forEach((src, i) => {
      header[`$comment${i + 3}`] = `  â€¢ ${src}`;
    });

    header[`$comment${sources.length + 3}`] =
      "To regenerate: pnpm config:apply";

    return JSON.stringify(header, null, 2);
  }

  /**
   * Generate YAML header using comments
   */
  private generateYamlHeader(sources: string[]): string {
    const lines = [
      "# ðŸ¤– GENERATED FILE - DO NOT EDIT DIRECTLY",
      "# This file is auto-generated by config-manager. Edit source files instead:",
      ...sources.map((src) => `#   â€¢ ${src}`),
      "# To regenerate: pnpm config:apply",
      "", // Empty line before content
    ];
    return lines.join("\n");
  }

  /**
   * Generate JSDoc-style header for TypeScript/JavaScript files
   */
  private generateJsDocHeader(sources: string[]): string {
    const lines = [
      "/**",
      " * ðŸ¤– GENERATED FILE - DO NOT EDIT DIRECTLY",
      " *",
      " * This file is auto-generated by config-manager. Edit source files instead:",
      ...sources.map((src) => ` *   â€¢ ${src}`),
      " *",
      " * To regenerate: pnpm config:apply",
      " */",
    ];
    return lines.join("\n");
  }

  /**
   * Generate hash-comment header for text files
   */
  private generateHashHeader(sources: string[]): string {
    const lines = [
      "# Generated by config-manager from:",
      ...sources.map((src) => `# - ${src}`),
      "# To regenerate: pnpm config:apply",
      "", // Empty line
    ];
    return lines.join("\n");
  }

  /**
   * Check if content already has a generated header
   */
  hasGeneratedHeader(content: string): boolean {
    return (
      content.includes("ðŸ¤– GENERATED FILE") ||
      content.includes("Generated by config-manager")
    );
  }

  /**
   * Remove existing generated header from content
   */
  removeHeader(content: string, ext: string): string {
    if ([".json", ".jsonc", ".json5"].includes(ext)) {
      // For JSON, parse and remove $comment properties
      try {
        const parsed = JSON.parse(content);
        const cleaned: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(parsed)) {
          if (!key.startsWith("$comment")) {
            cleaned[key] = value;
          }
        }
        return JSON.stringify(cleaned, null, 2);
      } catch {
        return content;
      }
    } else {
      // For other files, remove comment lines at the start
      const lines = content.split("\n");
      let i = 0;

      // Skip comment lines
      while (i < lines.length) {
        const line = lines[i].trim();
        if (
          line.startsWith("#") ||
          line.startsWith("//") ||
          line.startsWith("/*") ||
          line === ""
        ) {
          i++;
          if (line.includes("To regenerate:")) {
            // Found end of header, skip one more line if empty
            if (i < lines.length && lines[i].trim() === "") {
              i++;
            }
            break;
          }
        } else {
          break;
        }
      }

      return lines.slice(i).join("\n");
    }
  }
}
